allowedBlocks = [
  "acacia_log.png",
  "acacia_log_top.png",
  "acacia_planks.png",
  "ancient_debris_side.png",
  "ancient_debris_top.png",
  "andesite.png",
  "amethyst_block.png",
  "barrel_bottom.png",
  "barrel_side.png",
  "barrel_top.png",
  "barrel_top_open.png",
  "basalt_side.png",
  "basalt_top.png",
  "beacon.png",
  "bedrock.png",
  "beehive_end.png",
  "beehive_front.png",
  "beehive_front_honey.png",
  "beehive_side.png",
  "bee_nest_bottom.png",
  "bee_nest_front.png",
  "bee_nest_front_honey.png",
  "bee_nest_side.png",
  "bee_nest_top.png",
  "birch_log.png",
  "birch_log_top.png",
  "birch_planks.png",
  "blackstone.png",
  "blackstone_top.png",
  "black_concrete.png",
  "black_concrete_powder.png",
  "black_glazed_terracotta.png",
  "black_shulker_box.png",
  "black_terracotta.png",
  "black_wool.png",
  "blast_furnace_front.png",
  "blast_furnace_side.png",
  "blast_furnace_top.png",
  "blue_concrete.png",
  "blue_concrete_powder.png",
  "blue_glazed_terracotta.png",
  "blue_ice.png",
  "blue_shulker_box.png",
  "blue_terracotta.png",
  "blue_wool.png",
  "bone_block_side.png",
  "bone_block_top.png",
  "bookshelf.png",
  "brain_coral_block.png",
  "bricks.png",
  "brown_concrete.png",
  "brown_concrete_powder.png",
  "brown_glazed_terracotta.png",
  "brown_mushroom_block.png",
  "brown_shulker_box.png",
  "brown_terracotta.png",
  "brown_wool.png",
  "bubble_coral_block.png",
  "carved_pumpkin.png",
  "calcite.png",
  "cake_top.png",
  "chiseled_deepslate.png",
  "chiseled_nether_bricks.png",
  "chiseled_polished_blackstone.png",
  "chiseled_quartz_block.png",
  "chiseled_quartz_block_top.png",
  "chiseled_red_sandstone.png",
  "chiseled_sandstone.png",
  "chiseled_stone_bricks.png",
  "clay.png",
  "coal_block.png",
  "coal_ore.png",
  "coarse_dirt.png",
  "copper_block.png",
  "copper_ore.png",
  "cracked_deepslate_bricks.png",
  "cracked_deepslate_tiles.png",
  "cut_copper.png",
  "cobblestone.png",
  "cobbled_deepslate.png",
  "cracked_nether_bricks.png",
  "cracked_polished_blackstone_bricks.png",
  "cracked_stone_bricks.png",
  "crafting_table_front.png",
  "crafting_table_side.png",
  "crafting_table_top.png",
  "crimson_nylium.png",
  "crimson_planks.png",
  "crimson_stem_top.png",
  "crying_obsidian.png",
  "cut_red_sandstone.png",
  "cut_sandstone.png",
  "cyan_concrete.png",
  "cyan_concrete_powder.png",
  "cyan_glazed_terracotta.png",
  "cyan_shulker_box.png",
  "cyan_terracotta.png",
  "cyan_wool.png",
  "dark_oak_log.png",
  "dark_oak_log_top.png",
  "dark_oak_planks.png",
  "dark_prismarine.png",
  "daylight_detector_top.png",
  "dead_brain_coral_block.png",
  "dead_bubble_coral_block.png",
  "dead_fire_coral_block.png",
  "dead_horn_coral_block.png",
  "dead_tube_coral_block.png",
  "deepslate_bricks.png",
  "deepslate.png",
  "deepslate_top.png",
  "deepslate_bricks.png",
  "deepslate_coal_ore.png",
  "deepslate_copper_ore.png",
  "deepslate_diamond_ore.png",
  "deepslate_emerald_ore.png",
  "deepslate_gold_ore.png",
  "deepslate_iron_ore.png",
  "deepslate_lapis_ore.png",
  "deepslate_redstone_ore.png",
  "deepslate_tiles.png",
  "diamond_block.png",
  "diamond_ore.png",
  "diorite.png",
  "dirt.png",
  "dispenser_front.png",
  "dispenser_front_vertical.png",
  "dried_kelp_bottom.png",
  "dried_kelp_side.png",
  "dried_kelp_top.png",
  "dropper_front.png",
  "dropper_front_vertical.png",
  "emerald_block.png",
  "emerald_ore.png",
  "end_portal_frame_top.png",
  "end_stone.png",
  "exposed_copper.png",
  "exposed_cut_copper.png",
  "end_stone_bricks.png",
  "farmland.png",
  "farmland_moist.png",
  "fire_coral_block.png",
  "furnace_front.png",
  "furnace_front_on.png",
  "furnace_side.png",
  "furnace_top.png",
  "gilded_blackstone.png",
  "glowstone.png",
  "gold_block.png",
  "gold_ore.png",
  "granite.png",
  "gravel.png",
  "gray_concrete.png",
  "gray_concrete_powder.png",
  "gray_glazed_terracotta.png",
  "gray_shulker_box.png",
  "gray_terracotta.png",
  "gray_wool.png",
  "green_concrete.png",
  "green_concrete_powder.png",
  "green_glazed_terracotta.png",
  "green_shulker_box.png",
  "green_terracotta.png",
  "green_wool.png",
  "hay_block_side.png",
  "hay_block_top.png",
  "honeycomb_block.png",
  "horn_coral_block.png",
  "iron_block.png",
  "iron_ore.png",
  "jack_o_lantern.png",
  "jukebox_side.png",
  "jukebox_top.png",
  "jungle_log.png",
  "jungle_log_top.png",
  "jungle_planks.png",
  "lapis_block.png",
  "lapis_ore.png",
  "light_blue_concrete.png",
  "light_blue_concrete_powder.png",
  "light_blue_glazed_terracotta.png",
  "light_blue_shulker_box.png",
  "light_blue_terracotta.png",
  "light_blue_wool.png",
  "light_gray_concrete.png",
  "light_gray_concrete_powder.png",
  "light_gray_glazed_terracotta.png",
  "light_gray_shulker_box.png",
  "light_gray_terracotta.png",
  "light_gray_wool.png",
  "lime_concrete.png",
  "lime_concrete_powder.png",
  "lime_glazed_terracotta.png",
  "lime_shulker_box.png",
  "lime_terracotta.png",
  "lime_wool.png",
  "lodestone_side.png",
  "lodestone_top.png",
  "magenta_concrete.png",
  "magenta_concrete_powder.png",
  "magenta_glazed_terracotta.png",
  "magenta_shulker_box.png",
  "magenta_terracotta.png",
  "moss_block.png",
  "magenta_wool.png",
  "melon_side.png",
  "melon_top.png",
  "mossy_cobblestone.png",
  "mossy_stone_bricks.png",
  "mushroom_block_inside.png",
  "mycelium_top.png",
  "netherite_block.png",
  "netherrack.png",
  "nether_bricks.png",
  "nether_gold_ore.png",
  "nether_quartz_ore.png",
  "nether_wart_block.png",
  "note_block.png",
  "oak_log.png",
  "oak_log_top.png",
  "oak_planks.png",
  "oxidized_copper.png",
  "oxidized_cut_copper.png",
  "observer_back.png",
  "observer_back_on.png",
  "observer_front.png",
  "observer_side.png",
  "observer_top.png",
  "obsidian.png",
  "orange_concrete.png",
  "orange_concrete_powder.png",
  "orange_glazed_terracotta.png",
  "orange_shulker_box.png",
  "orange_terracotta.png",
  "orange_wool.png",
  "packed_ice.png",
  "pink_concrete.png",
  "pink_concrete_powder.png",
  "pink_glazed_terracotta.png",
  "pink_shulker_box.png",
  "pink_terracotta.png",
  "pink_wool.png",
  "piston_side.png",
  "piston_top.png",
  "polished_deepslate.png",
  "piston_top_sticky.png",
  "podzol_top.png",
  "polished_andesite.png",
  "powder_snow.png",
  "polished_basalt_side.png",
  "polished_basalt_top.png",
  "polished_blackstone.png",
  "polished_blackstone_bricks.png",
  "polished_diorite.png",
  "polished_granite.png",
  "prismarine_bricks.png",
  "pumpkin_side.png",
  "pumpkin_top.png",
  "purple_concrete.png",
  "purple_concrete_powder.png",
  "purple_glazed_terracotta.png",
  "purple_shulker_box.png",
  "purple_terracotta.png",
  "purple_wool.png",
  "purpur_block.png",
  "purpur_pillar.png",
  "purpur_pillar_top.png",
  "quartz_block_bottom.png",
  "quartz_block_side.png",
  "quartz_block_top.png",
  "quartz_bricks.png",
  "quartz_pillar.png",
  "quartz_pillar_top.png",
  "redstone_block.png",
  "redstone_lamp.png",
  "redstone_lamp_on.png",
  "redstone_ore.png",
  "red_concrete.png",
  "red_concrete_powder.png",
  "red_glazed_terracotta.png",
  "red_mushroom_block.png",
  "red_nether_bricks.png",
  "red_sand.png",
  "red_sandstone.png",
  "red_sandstone_top.png",
  "red_shulker_box.png",
  "red_terracotta.png",
  "red_wool.png",
  "raw_copper_block.png",
  "raw_gold_block.png",
  "raw_iron_block.png",
  "rooted_dirt.png",
  "sand.png",
  "sandstone.png",
  "sandstone_top.png",
  "shroomlight.png",
  "shulker_box.png",
  "smoker_front.png",
  "smoker_side.png",
  "smoker_top.png",
  "smooth_stone.png",
  "smooth_stone_slab_side.png",
  "snow.png",
  "soul_sand.png",
  "soul_soil.png",
  "sponge.png",
  "spruce_log.png",
  "spruce_log_top.png",
  "spruce_planks.png",
  "stone.png",
  "stone_bricks.png",
  "stripped_acacia_log.png",
  "stripped_acacia_log_top.png",
  "stripped_birch_log.png",
  "stripped_birch_log_top.png",
  "stripped_crimson_stem.png",
  "stripped_crimson_stem_top.png",
  "stripped_dark_oak_log.png",
  "stripped_dark_oak_log_top.png",
  "stripped_jungle_log.png",
  "stripped_jungle_log_top.png",
  "stripped_oak_log.png",
  "stripped_oak_log_top.png",
  "stripped_spruce_log.png",
  "stripped_spruce_log_top.png",
  "stripped_warped_stem.png",
  "stripped_warped_stem_top.png",
  "sculk_sensor_top.png",
  "stonecutter_top.png",
  "target_side.png",
  "target_top.png",
  "terracotta.png",
  "tnt_side.png",
  "tnt_top.png",
  "tube_coral_block.png",
  "warped_nylium.png",
  "warped_planks.png",
  "warped_stem_top.png",
  "warped_wart_block.png",
  "wet_sponge.png",
  "white_concrete.png",
  "white_concrete_powder.png",
  "white_glazed_terracotta.png",
  "white_shulker_box.png",
  "white_terracotta.png",
  "white_wool.png",
  "weathered_copper.png",
  "weathered_cut_copper.png",
  "yellow_concrete.png",
  "yellow_concrete_powder.png",
  "yellow_glazed_terracotta.png",
  "yellow_shulker_box.png",
  "yellow_terracotta.png",
  "yellow_wool.png",
];
  
  require( 'console-stamp' )( console );
  const { Image } = require("image-js");
  const cp = require("child_process");
  const fs = require("fs");
  const axios = require("axios");
  const { updateImage } = require(`${__dirname}/database.js`);
  
  (async () => {
    //console.log(process.argv)

    let usedBlocks = [];
    let path = process.argv[2];
    let runs = 0;
    let blockSize = process.argv[3];
    let sendMessageID = process.argv[4];
    let imageName = process.argv[5] + ".png";
    let minecraftBlockSize = 16;
  
    let colors = JSON.parse(fs.readFileSync(`${__dirname}/savedBlocks.json`));
  
    for (key in colors) {
      if (allowedBlocks.indexOf(key) == -1) {
        delete colors[key];
        console.log(`Stopped ${key} from being allowed!`);
      }
    }
  
    //console.log(colors);
    let nearestColor = require("nearest-color").from(colors);
  
    let pixels = []; // make pixel array
    let cachedPhotos = [];
  
    for (ci = 0; allowedBlocks.length > ci; ci++) {
      let mc = await Image.load(
        `${__dirname}/texturepack/assets/minecraft/textures/block/${allowedBlocks[ci]}`
      );
      await cachedPhotos.push(mc);
    }
  
    let mainImage = await Image.load(path); // read imaage
  
    if (mainImage.width - (mainImage.width % blockSize) > blockSize) {
      if (mainImage.height - (mainImage.height % blockSize) > blockSize) {
        if (mainImage.width % blockSize !== 0) {
          mainImage = await mainImage.resize({
            width: mainImage.width - (mainImage.width % blockSize),
            height: mainImage.height,
            preserveAspectRatio: false,
          });
          console.log('Resized width ' + blockSize)
        }
  
        if (mainImage.height % blockSize !== 0) {
          mainImage = await mainImage.resize({
            width: mainImage.width,
            height: mainImage.height - (mainImage.height % blockSize),
            preserveAspectRatio: false,
          });
          console.log('Resized height ' + blockSize)
        }
      } else {
        console.log("[ERROR] Image is too small");
        process.send(["An error has occurred. Your image may be too small"]);
        return;
      }
    } else {
      console.log("[ERROR] Image is too small");
      process.send(["An error has occurred. Your image may be too small"]);
      return;
    }
  
    // get with and height
    let width = mainImage.width;
    let height = mainImage.height;
  
    //console.log(width);
    //console.log(height)
  
    let mcImage = new Image(
      Math.floor(mainImage.width / blockSize) * minecraftBlockSize,
      Math.floor(mainImage.height / blockSize) * minecraftBlockSize
    );
  
    //console.log(mcImage.width);
    //console.log(mcImage.height)
  
    // get how many slizes
    let widthSlices = Math.floor(mainImage.width / blockSize);
    let heightSlices = Math.floor(mainImage.height / blockSize);
  
    start = new Date();

    for (let w = 0; widthSlices > w; w++) {
      // loop width
      for (let h = 0; heightSlices > h; h++) {
        // loop height
  
        let histograms = await mainImage
          .crop({
            x: blockSize * w,
            y: blockSize * h,
            width: blockSize,
            height: blockSize,
          })
          .colorDepth(8)
          .getHistograms({ maxSlots: mainImage.maxValue + 1 });
        let result = new Array(histograms.length);
        for (let c = 0; c < histograms.length; c++) {
          let histogram = histograms[c];
          result[c] = Math.floor(mean(histogram));
        }
  
        try {
          usingBlock = nearestColor(
            rgbToHex(result[0], result[1], result[2])
          ).name.replace(
            /\.png|_top|_side|_bottom|_front|_end|_inside|_vertical|_open|_back|_on|_honey/g,
            ""
          );
          //console.log(nearestColor(rgbToHex(result[0], result[1], result[2])));
          if (!searchArr(usedBlocks, usingBlock))
            usedBlocks.push({ n: usingBlock, a: 0 });
          usedBlocks.forEach((b) => {
            if (b.n === usingBlock) { // name
              b.a++; // amount
              return;
            }
          });
        } catch (e) {
          console.log(
            `[COLOR PICKER ERROR] ${e.toString()} R0: ${result[0]} R1: ${
              result[1]
            } R2: ${result[2]}`
          );
          //console.log(histograms);
          //console.log(mainImage.clone().crop({x: blockSize*w, y: blockSize*h, width: blockSize, height: blockSize}).getPixelsArray());
          await process.send([
            `Error creating image. If this continues, report it on our server ${config.supportURL}`,
          ]);
          try {
            fs.unlinkSync(path);
            fs.unlinkSync(path.replace("_tmp", ""));
          } catch {
            console.log(e);
          }
          process.exit();
        }
  
        try {
          let blockImage =
            cachedPhotos[
              allowedBlocks.indexOf(
                nearestColor(rgbToHex(result[0], result[1], result[2])).name
              )
            ];
  
          await mcImage.insert(await blockImage, {
            x: minecraftBlockSize * w,
            y: minecraftBlockSize * h,
            inPlace: true,
          });
        } catch (e) {
          console.log(`[IMAGE INSERT ERROR] ${e.toString()}`);
          await process.send([
            `Error creating image. If this continues, report it on our server ${config.supportURL}`,
          ]);
          try {
            fs.unlinkSync(path);
            fs.unlinkSync(path.replace("_tmp", ""));
          } catch {
            console.log(e);
          }
          process.exit();
        }
  
        runs++;
      }
    }

    end = new Date();

    console.log(end.getTime() - start.getTime() + "ms\nRuns: " + runs);

    usedBlocks.sort(sortArr("a")); // sort by amount
  
    await mcImage.save(path);
  
    /*
  try {
  size = getFilesizeInBytes(path).toFixed(2);
  fs.writeFileSync(`${__dirname}/data/${messageID}.json`, `{"size":${size}, "width": ${mcImage.width}, "height": ${mcImage.height}, "blockAmount": ${runs}, "name":${imageName}, "blocks":${JSON.stringify(usedBlocks)}}`);
  } catch(e) {
      console.log(e);
  }
  */
  
  try {
    const size = getFilesizeInBytes(path).toFixed(2);

    const jsonString = JSON.stringify({
      size: size,
      width: mcImage.width,
      height: mcImage.height,
      blockAmount: runs,
      name: imageName,
      blocks: usedBlocks,
    });
    console.log(sendMessageID)

    await updateImage({interaction: sendMessageID, key: 'blockData', value: jsonString});


  } catch(err) {
    console.error(err);
  }
  /*
    try {
      size = getFilesizeInBytes(path).toFixed(2);
      const res = await axios.post(
        `https://minecraftimagebot.glitch.me/saveimage`,
        JSON.stringify({
          id: sendMessageID,
          size: size,
          width: mcImage.width,
          height: mcImage.height,
          blockAmount: runs,
          name: imageName,
          blocks: JSON.stringify(usedBlocks),
        }),
        {
          headers: {
            auth: "Q4JsH0mQrWfkTmHJ4pfR",
            "Content-Type": "application/json",
          },
        }
      );
    } catch (e) {
      console.log(e);
    }
    */
  
    await process.send(["done", path]);
  })();
  
  function getFilesizeInBytes(filename) {
    var stats = fs.statSync(filename);
    var fileSizeInBytes = stats["size"] / 1048576;
    return fileSizeInBytes;
  }
  
  function sortArr(prop) {
    return function (a, b) {
      if (a[prop] < b[prop]) {
        return 1;
      } else if (a[prop] > b[prop]) {
        return -1;
      }
      return 0;
    };
  }
  
  function searchArr(arr, name) {
    for (let i = 0; arr.length > i; i++) {
      if (arr[i].n === name) return true;
    }
    return false;
  }
  
  function rgbToHex(r, g, b) {
    return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
  }
  
  function mean(histogram) {
    let total = 0;
    let sum = 0;
  
    for (let i = 0; i < histogram.length; i++) {
      total += histogram[i];
      sum += histogram[i] * i;
    }
    if (total === 0) {
      return 0;
    }
  
    return sum / total;
  }
  